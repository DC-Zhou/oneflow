/* File automatically generated by asdl/asdl_cpp.py. */

#pragma once

#include <vector>
#include <string>
#include <any>

namespace pyast {

typedef std::string identifier;
typedef void* pointer;

class BaseVisitor;

struct stmt_;
typedef stmt_* stmt_t;

struct FunctionDef_;
typedef FunctionDef_* FunctionDef_t;

struct Return_;
typedef Return_* Return_t;

struct Assign_;
typedef Assign_* Assign_t;

struct If_;
typedef If_* If_t;

struct Raise_;
typedef Raise_* Raise_t;

struct Assert_;
typedef Assert_* Assert_t;

struct Expr_;
typedef Expr_* Expr_t;

struct expr_;
typedef expr_* expr_t;

struct BoolOp_;
typedef BoolOp_* BoolOp_t;

struct BinOp_;
typedef BinOp_* BinOp_t;

struct Lambda_;
typedef Lambda_* Lambda_t;

struct Compare_;
typedef Compare_* Compare_t;

struct Call_;
typedef Call_* Call_t;

struct Num_;
typedef Num_* Num_t;

struct Constant_;
typedef Constant_* Constant_t;

struct Attribute_;
typedef Attribute_* Attribute_t;

struct Name_;
typedef Name_* Name_t;

enum class boolop_t : uint8_t { kAnd=1, kOr=2 };

enum class operator_t : uint8_t { kAdd=1, kSub=2, kMult=3, kDiv=4, kPow=5 };

enum class cmpop_t : uint8_t { kEq=1, kNotEq=2, kLt=3, kLtE=4, kGt=5, kGtE=6 };

struct arguments_;
typedef arguments_* arguments_t;

struct arg_;
typedef arg_* arg_t;


struct stmt_ {
    enum class StmtKind : uint8_t { kFunctionDef=1, kReturn=2, kAssign=3,
                                                  kIf=4, kRaise=5, kAssert=6,
                                                  kExpr=7 } stmt_kind;
    virtual std::any visit(BaseVisitor&) = 0;
};

struct expr_ {
    enum class ExprKind : uint8_t { kBoolOp=1, kBinOp=2, kLambda=3, kCompare=4,
                                             kCall=5, kNum=6, kConstant=7,
                                             kAttribute=8, kName=9 } expr_kind;
    virtual std::any visit(BaseVisitor&) = 0;
};

struct arguments_ {
    std::vector<arg_t> args;

    arguments_(const std::vector<arg_t>& args_) : args(args_) {}
};

struct arg_ {
    identifier arg;

    arg_(const identifier& arg_) : arg(arg_) {}
};


class BaseVisitor {
public:
    std::any visit(stmt_t node) {
        return node->visit(*this);
    }

    std::any visit(expr_t node) {
        return node->visit(*this);
    }

    std::any visit(boolop_t node) {
        return visitBoolop(node);
    }

    std::any visit(operator_t node) {
        return visitOperator(node);
    }

    std::any visit(cmpop_t node) {
        return visitCmpop(node);
    }

    std::any visit(arguments_t node) {
        return visitArguments(node);
    }

    std::any visit(arg_t node) {
        return visitArg(node);
    }

    virtual std::any visitFunctionDef(FunctionDef_t node) = 0;
    virtual std::any visitReturn(Return_t node) = 0;
    virtual std::any visitAssign(Assign_t node) = 0;
    virtual std::any visitIf(If_t node) = 0;
    virtual std::any visitRaise(Raise_t node) = 0;
    virtual std::any visitAssert(Assert_t node) = 0;
    virtual std::any visitExpr(Expr_t node) = 0;
    virtual std::any visitBoolOp(BoolOp_t node) = 0;
    virtual std::any visitBinOp(BinOp_t node) = 0;
    virtual std::any visitLambda(Lambda_t node) = 0;
    virtual std::any visitCompare(Compare_t node) = 0;
    virtual std::any visitCall(Call_t node) = 0;
    virtual std::any visitNum(Num_t node) = 0;
    virtual std::any visitConstant(Constant_t node) = 0;
    virtual std::any visitAttribute(Attribute_t node) = 0;
    virtual std::any visitName(Name_t node) = 0;
    virtual std::any visitBoolop(boolop_t value) = 0;
    virtual std::any visitOperator(operator_t value) = 0;
    virtual std::any visitCmpop(cmpop_t value) = 0;
    virtual std::any visitArguments(arguments_t node) = 0;
    virtual std::any visitArg(arg_t node) = 0;
};

struct FunctionDef_ : stmt_ {
    identifier name;
    arguments_t args;
    std::vector<stmt_t> body;

    FunctionDef_(const identifier& name_, arguments_t args_, const
                 std::vector<stmt_t>& body_) : name(name_), args(args_),
                 body(body_), stmt_() {
        stmt_kind = stmt_::StmtKind::kFunctionDef;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitFunctionDef(this);
    }

};

struct Return_ : stmt_ {
    expr_t value;

    Return_(expr_t value_) : value(value_), stmt_() {
        stmt_kind = stmt_::StmtKind::kReturn;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitReturn(this);
    }

};

struct Assign_ : stmt_ {
    std::vector<expr_t> targets;
    expr_t value;

    Assign_(const std::vector<expr_t>& targets_, expr_t value_) :
            targets(targets_), value(value_), stmt_() {
        stmt_kind = stmt_::StmtKind::kAssign;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitAssign(this);
    }

};

struct If_ : stmt_ {
    expr_t test;
    std::vector<stmt_t> body;
    std::vector<stmt_t> orelse;

    If_(expr_t test_, const std::vector<stmt_t>& body_, const
        std::vector<stmt_t>& orelse_) : test(test_), body(body_),
        orelse(orelse_), stmt_() {
        stmt_kind = stmt_::StmtKind::kIf;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitIf(this);
    }

};

struct Raise_ : stmt_ {
    expr_t exc;
    expr_t cause;

    Raise_(expr_t exc_, expr_t cause_) : exc(exc_), cause(cause_), stmt_() {
        stmt_kind = stmt_::StmtKind::kRaise;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitRaise(this);
    }

};

struct Assert_ : stmt_ {
    expr_t test;
    expr_t msg;

    Assert_(expr_t test_, expr_t msg_) : test(test_), msg(msg_), stmt_() {
        stmt_kind = stmt_::StmtKind::kAssert;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitAssert(this);
    }

};

struct Expr_ : stmt_ {
    expr_t value;

    Expr_(expr_t value_) : value(value_), stmt_() {
        stmt_kind = stmt_::StmtKind::kExpr;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitExpr(this);
    }

};

struct BoolOp_ : expr_ {
    boolop_t op;
    std::vector<expr_t> values;

    BoolOp_(boolop_t op_, const std::vector<expr_t>& values_) : op(op_),
            values(values_), expr_() {
        expr_kind = expr_::ExprKind::kBoolOp;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitBoolOp(this);
    }

};

struct BinOp_ : expr_ {
    expr_t left;
    operator_t op;
    expr_t right;

    BinOp_(expr_t left_, operator_t op_, expr_t right_) : left(left_), op(op_),
           right(right_), expr_() {
        expr_kind = expr_::ExprKind::kBinOp;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitBinOp(this);
    }

};

struct Lambda_ : expr_ {
    arguments_t args;
    expr_t body;

    Lambda_(arguments_t args_, expr_t body_) : args(args_), body(body_),
            expr_() {
        expr_kind = expr_::ExprKind::kLambda;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitLambda(this);
    }

};

struct Compare_ : expr_ {
    expr_t left;
    std::vector<cmpop_t> ops;
    std::vector<expr_t> comparators;

    Compare_(expr_t left_, const std::vector<cmpop_t>& ops_, const
             std::vector<expr_t>& comparators_) : left(left_), ops(ops_),
             comparators(comparators_), expr_() {
        expr_kind = expr_::ExprKind::kCompare;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitCompare(this);
    }

};

struct Call_ : expr_ {
    expr_t func;
    std::vector<expr_t> args;

    Call_(expr_t func_, const std::vector<expr_t>& args_) : func(func_),
          args(args_), expr_() {
        expr_kind = expr_::ExprKind::kCall;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitCall(this);
    }

};

struct Num_ : expr_ {
    double n;

    Num_(double n_) : n(n_), expr_() {
        expr_kind = expr_::ExprKind::kNum;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitNum(this);
    }

};

struct Constant_ : expr_ {
    double value;

    Constant_(double value_) : value(value_), expr_() {
        expr_kind = expr_::ExprKind::kConstant;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitConstant(this);
    }

};

struct Attribute_ : expr_ {
    expr_t value;
    identifier attr;

    Attribute_(expr_t value_, const identifier& attr_) : value(value_),
               attr(attr_), expr_() {
        expr_kind = expr_::ExprKind::kAttribute;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitAttribute(this);
    }

};

struct Name_ : expr_ {
    identifier id;

    Name_(const identifier& id_) : id(id_), expr_() {
        expr_kind = expr_::ExprKind::kName;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitName(this);
    }

};


stmt_t FunctionDef(const identifier& name, arguments_t args, const
                   std::vector<stmt_t>& body);
stmt_t Return(expr_t value);
stmt_t Assign(const std::vector<expr_t>& targets, expr_t value);
stmt_t If(expr_t test, const std::vector<stmt_t>& body, const
          std::vector<stmt_t>& orelse);
stmt_t Raise(expr_t exc, expr_t cause);
stmt_t Assert(expr_t test, expr_t msg);
stmt_t Expr(expr_t value);
expr_t BoolOp(boolop_t op, const std::vector<expr_t>& values);
expr_t BinOp(expr_t left, operator_t op, expr_t right);
expr_t Lambda(arguments_t args, expr_t body);
expr_t Compare(expr_t left, const std::vector<cmpop_t>& ops, const
               std::vector<expr_t>& comparators);
expr_t Call(expr_t func, const std::vector<expr_t>& args);
expr_t Num(double n);
expr_t Constant(double value);
expr_t Attribute(expr_t value, const identifier& attr);
expr_t Name(const identifier& id);
arguments_t arguments(const std::vector<arg_t>& args);
arg_t arg(const identifier& arg);

}
