/* File automatically generated by asdl/asdl_cpp.py. */

#pragma once

#include <vector>
#include <string>
#include <any>

namespace PythonAST {

typedef std::string identifier;
typedef void* pointer;

class BaseVisitor;

struct mod_;
typedef mod_* mod_t;

struct Module_;
typedef Module_* Module_t;

struct stmt_;
typedef stmt_* stmt_t;

struct FunctionDef_;
typedef FunctionDef_* FunctionDef_t;

struct Return_;
typedef Return_* Return_t;

struct Assign_;
typedef Assign_* Assign_t;

struct For_;
typedef For_* For_t;

struct While_;
typedef While_* While_t;

struct If_;
typedef If_* If_t;

struct Raise_;
typedef Raise_* Raise_t;

struct Assert_;
typedef Assert_* Assert_t;

struct Expr_;
typedef Expr_* Expr_t;

struct Pass_;
typedef Pass_* Pass_t;

struct Break_;
typedef Break_* Break_t;

struct Continue_;
typedef Continue_* Continue_t;

struct expr_;
typedef expr_* expr_t;

struct BoolOp_;
typedef BoolOp_* BoolOp_t;

struct BinOp_;
typedef BinOp_* BinOp_t;

struct Lambda_;
typedef Lambda_* Lambda_t;

struct IfExp_;
typedef IfExp_* IfExp_t;

struct Compare_;
typedef Compare_* Compare_t;

struct Call_;
typedef Call_* Call_t;

struct Num_;
typedef Num_* Num_t;

struct Constant_;
typedef Constant_* Constant_t;

struct Attribute_;
typedef Attribute_* Attribute_t;

struct Name_;
typedef Name_* Name_t;

enum class expr_context_t : uint8_t { kLoad=1, kStore=2, kDel=3, kAugLoad=4,
                                             kAugStore=5, kParam=6 };

enum class boolop_t : uint8_t { kAnd=1, kOr=2 };

enum class operator_t : uint8_t { kAdd=1, kSub=2, kMult=3, kDiv=4, kPow=5 };

enum class cmpop_t : uint8_t { kEq=1, kNotEq=2, kLt=3, kLtE=4, kGt=5, kGtE=6,
                                    kIs=7, kIsNot=8, kIn=9, kNotIn=10 };

struct arguments_;
typedef arguments_* arguments_t;

struct arg_;
typedef arg_* arg_t;


struct mod_ {
    enum class ModKind : uint8_t { kModule=1 } mod_kind;
    virtual std::any visit(BaseVisitor&) = 0;
};

struct stmt_ {
    enum class StmtKind : uint8_t { kFunctionDef=1, kReturn=2, kAssign=3,
                                                  kFor=4, kWhile=5, kIf=6,
                                                  kRaise=7, kAssert=8, kExpr=9,
                                                  kPass=10, kBreak=11,
                                                  kContinue=12 } stmt_kind;
    virtual std::any visit(BaseVisitor&) = 0;
};

struct expr_ {
    enum class ExprKind : uint8_t { kBoolOp=1, kBinOp=2, kLambda=3, kIfExp=4,
                                             kCompare=5, kCall=6, kNum=7,
                                             kConstant=8, kAttribute=9,
                                             kName=10 } expr_kind;
    virtual std::any visit(BaseVisitor&) = 0;
};

struct arguments_ {
    std::vector<arg_t> args;

    arguments_(const std::vector<arg_t>& args_) : args(args_) {}
};

struct arg_ {
    identifier arg;

    arg_(const identifier& arg_) : arg(arg_) {}
};


class BaseVisitor {
public:
    std::any visit(mod_t node) {
        return node->visit(*this);
    }

    std::any visit(stmt_t node) {
        return node->visit(*this);
    }

    std::any visit(expr_t node) {
        return node->visit(*this);
    }

    std::any visit(expr_context_t node) {
        return visitExpr_Context(node);
    }

    std::any visit(boolop_t node) {
        return visitBoolop(node);
    }

    std::any visit(operator_t node) {
        return visitOperator(node);
    }

    std::any visit(cmpop_t node) {
        return visitCmpop(node);
    }

    std::any visit(arguments_t node) {
        return visitArguments(node);
    }

    std::any visit(arg_t node) {
        return visitArg(node);
    }

    virtual std::any visitModule(Module_t node) = 0;
    virtual std::any visitFunctionDef(FunctionDef_t node) = 0;
    virtual std::any visitReturn(Return_t node) = 0;
    virtual std::any visitAssign(Assign_t node) = 0;
    virtual std::any visitFor(For_t node) = 0;
    virtual std::any visitWhile(While_t node) = 0;
    virtual std::any visitIf(If_t node) = 0;
    virtual std::any visitRaise(Raise_t node) = 0;
    virtual std::any visitAssert(Assert_t node) = 0;
    virtual std::any visitExpr(Expr_t node) = 0;
    virtual std::any visitPass(Pass_t node) = 0;
    virtual std::any visitBreak(Break_t node) = 0;
    virtual std::any visitContinue(Continue_t node) = 0;
    virtual std::any visitBoolOp(BoolOp_t node) = 0;
    virtual std::any visitBinOp(BinOp_t node) = 0;
    virtual std::any visitLambda(Lambda_t node) = 0;
    virtual std::any visitIfExp(IfExp_t node) = 0;
    virtual std::any visitCompare(Compare_t node) = 0;
    virtual std::any visitCall(Call_t node) = 0;
    virtual std::any visitNum(Num_t node) = 0;
    virtual std::any visitConstant(Constant_t node) = 0;
    virtual std::any visitAttribute(Attribute_t node) = 0;
    virtual std::any visitName(Name_t node) = 0;
    virtual std::any visitExpr_Context(expr_context_t value) = 0;
    virtual std::any visitBoolop(boolop_t value) = 0;
    virtual std::any visitOperator(operator_t value) = 0;
    virtual std::any visitCmpop(cmpop_t value) = 0;
    virtual std::any visitArguments(arguments_t node) = 0;
    virtual std::any visitArg(arg_t node) = 0;
};

struct Module_ : mod_ {
    std::vector<stmt_t> body;

    Module_(const std::vector<stmt_t>& body_) : body(body_), mod_() {
        mod_kind = mod_::ModKind::kModule;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitModule(this);
    }

};

struct FunctionDef_ : stmt_ {
    identifier name;
    arguments_t args;
    std::vector<stmt_t> body;

    FunctionDef_(const identifier& name_, arguments_t args_, const
                 std::vector<stmt_t>& body_) : name(name_), args(args_),
                 body(body_), stmt_() {
        stmt_kind = stmt_::StmtKind::kFunctionDef;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitFunctionDef(this);
    }

};

struct Return_ : stmt_ {
    expr_t value;

    Return_(expr_t value_) : value(value_), stmt_() {
        stmt_kind = stmt_::StmtKind::kReturn;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitReturn(this);
    }

};

struct Assign_ : stmt_ {
    std::vector<expr_t> targets;
    expr_t value;

    Assign_(const std::vector<expr_t>& targets_, expr_t value_) :
            targets(targets_), value(value_), stmt_() {
        stmt_kind = stmt_::StmtKind::kAssign;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitAssign(this);
    }

};

struct For_ : stmt_ {
    expr_t target;
    expr_t iter;
    std::vector<stmt_t> body;
    std::vector<stmt_t> orelse;

    For_(expr_t target_, expr_t iter_, const std::vector<stmt_t>& body_, const
         std::vector<stmt_t>& orelse_) : target(target_), iter(iter_),
         body(body_), orelse(orelse_), stmt_() {
        stmt_kind = stmt_::StmtKind::kFor;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitFor(this);
    }

};

struct While_ : stmt_ {
    expr_t test;
    std::vector<stmt_t> body;
    std::vector<stmt_t> orelse;

    While_(expr_t test_, const std::vector<stmt_t>& body_, const
           std::vector<stmt_t>& orelse_) : test(test_), body(body_),
           orelse(orelse_), stmt_() {
        stmt_kind = stmt_::StmtKind::kWhile;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitWhile(this);
    }

};

struct If_ : stmt_ {
    expr_t test;
    std::vector<stmt_t> body;
    std::vector<stmt_t> orelse;

    If_(expr_t test_, const std::vector<stmt_t>& body_, const
        std::vector<stmt_t>& orelse_) : test(test_), body(body_),
        orelse(orelse_), stmt_() {
        stmt_kind = stmt_::StmtKind::kIf;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitIf(this);
    }

};

struct Raise_ : stmt_ {
    expr_t exc;
    expr_t cause;

    Raise_(expr_t exc_, expr_t cause_) : exc(exc_), cause(cause_), stmt_() {
        stmt_kind = stmt_::StmtKind::kRaise;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitRaise(this);
    }

};

struct Assert_ : stmt_ {
    expr_t test;
    expr_t msg;

    Assert_(expr_t test_, expr_t msg_) : test(test_), msg(msg_), stmt_() {
        stmt_kind = stmt_::StmtKind::kAssert;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitAssert(this);
    }

};

struct Expr_ : stmt_ {
    expr_t value;

    Expr_(expr_t value_) : value(value_), stmt_() {
        stmt_kind = stmt_::StmtKind::kExpr;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitExpr(this);
    }

};

struct Pass_ : stmt_ {

    Pass_() : stmt_() {
        stmt_kind = stmt_::StmtKind::kPass;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitPass(this);
    }

};

struct Break_ : stmt_ {

    Break_() : stmt_() {
        stmt_kind = stmt_::StmtKind::kBreak;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitBreak(this);
    }

};

struct Continue_ : stmt_ {

    Continue_() : stmt_() {
        stmt_kind = stmt_::StmtKind::kContinue;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitContinue(this);
    }

};

struct BoolOp_ : expr_ {
    boolop_t op;
    std::vector<expr_t> values;

    BoolOp_(boolop_t op_, const std::vector<expr_t>& values_) : op(op_),
            values(values_), expr_() {
        expr_kind = expr_::ExprKind::kBoolOp;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitBoolOp(this);
    }

};

struct BinOp_ : expr_ {
    expr_t left;
    operator_t op;
    expr_t right;

    BinOp_(expr_t left_, operator_t op_, expr_t right_) : left(left_), op(op_),
           right(right_), expr_() {
        expr_kind = expr_::ExprKind::kBinOp;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitBinOp(this);
    }

};

struct Lambda_ : expr_ {
    arguments_t args;
    expr_t body;

    Lambda_(arguments_t args_, expr_t body_) : args(args_), body(body_),
            expr_() {
        expr_kind = expr_::ExprKind::kLambda;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitLambda(this);
    }

};

struct IfExp_ : expr_ {
    expr_t test;
    expr_t body;
    expr_t orelse;

    IfExp_(expr_t test_, expr_t body_, expr_t orelse_) : test(test_),
           body(body_), orelse(orelse_), expr_() {
        expr_kind = expr_::ExprKind::kIfExp;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitIfExp(this);
    }

};

struct Compare_ : expr_ {
    expr_t left;
    std::vector<cmpop_t> ops;
    std::vector<expr_t> comparators;

    Compare_(expr_t left_, const std::vector<cmpop_t>& ops_, const
             std::vector<expr_t>& comparators_) : left(left_), ops(ops_),
             comparators(comparators_), expr_() {
        expr_kind = expr_::ExprKind::kCompare;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitCompare(this);
    }

};

struct Call_ : expr_ {
    expr_t func;
    std::vector<expr_t> args;

    Call_(expr_t func_, const std::vector<expr_t>& args_) : func(func_),
          args(args_), expr_() {
        expr_kind = expr_::ExprKind::kCall;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitCall(this);
    }

};

struct Num_ : expr_ {
    double n;

    Num_(double n_) : n(n_), expr_() {
        expr_kind = expr_::ExprKind::kNum;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitNum(this);
    }

};

struct Constant_ : expr_ {
    double value;

    Constant_(double value_) : value(value_), expr_() {
        expr_kind = expr_::ExprKind::kConstant;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitConstant(this);
    }

};

struct Attribute_ : expr_ {
    expr_t value;
    identifier attr;
    expr_context_t ctx;

    Attribute_(expr_t value_, const identifier& attr_, expr_context_t ctx_) :
               value(value_), attr(attr_), ctx(ctx_), expr_() {
        expr_kind = expr_::ExprKind::kAttribute;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitAttribute(this);
    }

};

struct Name_ : expr_ {
    identifier id;
    expr_context_t ctx;

    Name_(const identifier& id_, expr_context_t ctx_) : id(id_), ctx(ctx_),
          expr_() {
        expr_kind = expr_::ExprKind::kName;
    }

    std::any visit(BaseVisitor& v) override {
        return v.visitName(this);
    }

};


mod_t Module(const std::vector<stmt_t>& body);
stmt_t FunctionDef(const identifier& name, arguments_t args, const
                   std::vector<stmt_t>& body);
stmt_t Return(expr_t value);
stmt_t Assign(const std::vector<expr_t>& targets, expr_t value);
stmt_t For(expr_t target, expr_t iter, const std::vector<stmt_t>& body, const
           std::vector<stmt_t>& orelse);
stmt_t While(expr_t test, const std::vector<stmt_t>& body, const
             std::vector<stmt_t>& orelse);
stmt_t If(expr_t test, const std::vector<stmt_t>& body, const
          std::vector<stmt_t>& orelse);
stmt_t Raise(expr_t exc, expr_t cause);
stmt_t Assert(expr_t test, expr_t msg);
stmt_t Expr(expr_t value);
stmt_t Pass();
stmt_t Break();
stmt_t Continue();
expr_t BoolOp(boolop_t op, const std::vector<expr_t>& values);
expr_t BinOp(expr_t left, operator_t op, expr_t right);
expr_t Lambda(arguments_t args, expr_t body);
expr_t IfExp(expr_t test, expr_t body, expr_t orelse);
expr_t Compare(expr_t left, const std::vector<cmpop_t>& ops, const
               std::vector<expr_t>& comparators);
expr_t Call(expr_t func, const std::vector<expr_t>& args);
expr_t Num(double n);
expr_t Constant(double value);
expr_t Attribute(expr_t value, const identifier& attr, expr_context_t ctx);
expr_t Name(const identifier& id, expr_context_t ctx);
arguments_t arguments(const std::vector<arg_t>& args);
arg_t arg(const identifier& arg);

std::string to_string(mod_t node);
std::string to_string(stmt_t node);
std::string to_string(expr_t node);
std::string to_string(expr_context_t node);
std::string to_string(boolop_t node);
std::string to_string(operator_t node);
std::string to_string(cmpop_t node);
std::string to_string(arguments_t node);
std::string to_string(arg_t node);

}
